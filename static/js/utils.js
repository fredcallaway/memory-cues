function updateExisting(target, src) {
  Object.keys(target)
        .forEach(k => target[k] = (src.hasOwnProperty(k) ? src[k] : target[k]));
}

function randString(n) {
  s = ''
  while (s.length < n) {
    s += _.sample("abcdefghijklmnopqrstuvwxyz")
  }
  return s
}

function randStringCons(n) {
  s = ''
  while (s.length < n) {
    s += _.sample("bcdfghjklmnpqrstvwxz")
  }
  return s
}

function maybeJson(s) {
  try {
    return JSON.parse(s);
  } catch (error) {
    return s;
  }
};

function sum(xs) {
  return xs.reduce((a, b) => a+b)
}
function mean(xs) {
  return sum(xs) / length(xs)
}

function make_radio(div, question, choices) {
  $("<p>")
  .css('margin-top', 20)
  .html(question)
  .appendTo(div)

  let name = ('R' + Math.random()).replace('.', '')
  $('<div>')
  .html(choices.map(choice => `
    <input type="radio" id="${choice}" name="${name}" value="${choice}">
    <label for="${choice}">${choice}&nbsp;&nbsp;</label>
  `).join('\n'))
  .appendTo(div)
  console.log('radio name', name)
  return () => $(`input[name=${name}]:checked`).val()
}

function make_text(div, question, opts={}) {
      let {height=50, width='80%'} = opts
      $("<p>")
      .css('margin-top', 20)
      .html(question)
      .appendTo(div)

      let text = $('<textarea>')
      .css({
        margin: '10px 10%',
        padding: '10px',
        width,
        height
      })
      .appendTo(div)
      .focus()

      return () => text.val()
}

function make_slider(opt) {
  console.log('make_slider', opt)
  let slider = $("<div>")
  .css('margin', '60px')
  .slider(opt)
  for (let [lab, val] of Object.entries(opt.labels)) {
    let pos = (val - opt.min) / (opt.max - opt.min)
    $(`<label>${lab}</label>`)
    .css({
      'position': 'absolute',
      'left': `${100 * pos}%`,
      'text-align': 'center',
      'width': '150px',
      'transform': 'translate(-50%, 100%)',
    })
    .appendTo(slider)
  }
  return slider
}

async function make_button(div, text, opts={}) {
  let {pre_delay=0, post_delay=0.2, cls = 'btn btn-primary center'} = opts;

  let id = text.toLowerCase().replace(' ', '-')
  let btn = $('<button>', {class: cls, id})
  .text(text)
  .appendTo(div)

  if (pre_delay > 0) {
    btn.prop('disabled', true)
    await sleep(1000 * pre_delay)
    btn.prop('disabled', false)
  }
  await new Promise(resolve => btn.click(resolve))
  btn.prop('disabled', true)
  await sleep(1000 * post_delay)
  return text
}

async function make_buttons(div, texts, opts={}) {
  container = $('<div>')
  .css('text-align', 'center')
  .appendTo(div)
  opts.cls = 'btn btn-primary'
  let buttons = texts.map(t => make_button(container, t, opts))
  let prom = Promise.any(buttons)
  if (opts.remove_after) {
    prom.then(() => container.remove())
  }
  return prom
}


function getKeyPress(options) {
  return new Promise(function(resolve) {
    return jsPsych.pluginAPI.getKeyboardResponse({
      valid_responses: options,
      persist: false,
      allow_held_key: false,
      callback_function: (info) => {
        info.key = String.fromCharCode(info.key);
        if (info.key == ' ') {
          info.key = 'space';
        }
        return resolve(info);
      }
    });
  });
};

function makeTimer(seconds, div) {
  let timer = {}
  timer.span = $('<span/>', {class: 'timer'})
  .css('font-size', 30)
  .css('font-weight', 'bold')
  .appendTo(div)

  timer.seconds_left = seconds
  timer.promise = new Promise(async function(resolve) {
    while (timer.seconds_left > 0) {
      timer.seconds_left -= 1
      timer.span.html(timer.seconds_left)
      await sleep(1000)
    }
    timer.span.html(0)
    resolve()
  })
  return timer
}

// Generated by CoffeeScript 2.0.2
var assert, check, checkObj, converter, delay, mapObject, markdown, mean, sleep, zip;




converter = new showdown.Converter();

markdown = function(txt) {
  // Remove leading spaces so as not to interpret indented
  // blocks as code blocks. Use fenced code blocks instead.
  return converter.makeHtml(txt.replace(/^[ ]+/gm, ''));
};

delay = function(time, func) {
  return setTimeout(func, time);
};

sleep = function(ms) {
  return new Promise(function(resolve) {
    return window.setTimeout(resolve, ms);
  });
};

zip = function(...rows) {
  return rows[0].map(function(_, c) {
    return rows.map(function(row) {
      return row[c];
    });
  });
};

mapObject = function(obj, fn) {
  return Object.keys(obj).reduce(function(res, key) {
    res[key] = fn(obj[key]);
    return res;
  }, {});
};

mean = function(xs) {
  return (xs.reduce((function(acc, x) {
    return acc + x;
  }))) / xs.length;
};

checkObj = function(obj, keys) {
  var i, k, len;
  if (keys == null) {
    keys = Object.keys(obj);
  }
  for (i = 0, len = keys.length; i < len; i++) {
    k = keys[i];
    if (obj[k] === void 0) {
      console.log('Bad Object: ', obj);
      throw new Error(`${k} is undefined`);
    }
  }
  return obj;
};

check = function(name, val) {
  if (val === void 0) {
    throw new Error(`${name}is undefined`);
  }
  return val;
};

assert = function(val) {
  if (!val) {
    throw new Error('Assertion Error');
  }
  return val;
};
